/*
”The Eva Airways and the Institute for the Information Industry (the owners hereafter) equally possess
the intellectual property of this software source codes document herein. The owners may have patents,
patent applications, trademarks, copyrights or other intellectual property rights covering the subject matters
in this document. Except as expressly provided in any written license agreement from the owners, the furnishing of this document does not give
any one any license to the aforementioned intellectual property.
The names of actual companies and products mentioned herein may be the trademarks of their respective owners.”
*/
//*****************************************************************************
//* WHO          | Version | chang no | Issue Date                            *
//*---------------------------------------------------------------------------*
//* comment                                                                   *
//*****************************************************************************
//* WUPC      | Ver. 00 | #BR071004 | 2007/OCT/03                             *
//*---------------------------------------------------------------------------*
//* Maintain Latch Position in DB                                             *
//*****************************************************************************
//* WUPC      | Ver. 00 | #BR071007 | 2007/OCT/03                             *
//*---------------------------------------------------------------------------*
//* Maintain SpecialLoad Restriction in DB                                    *
//*****************************************************************************
//* weiwang      | Ver. 00 | #BR071001 | 2007/OCT/22                          *
//*---------------------------------------------------------------------------*
//* Add CargoVersion() for auto load plan.                                    * 
//*****************************************************************************
//* Cherry    | Ver. 01 | #BR09113  | 2009/AUG/15    (V1.07)                  *
//*---------------------------------------------------------------------------*
//* Trim Sheet change index to decimal point                                  *
// This source code was auto-generated by xsd, Version=1.1.4322.2032.         *
//*****************************************************************************
//* THOMAS      | Ver. 01 | #BR17203 | 2017/08/02                             *
//*---------------------------------------------------------------------------*
//* 新增LargePalletOverLap                                                    *
//*****************************************************************************
//* Thomas    | Ver. 02 | #BR17208  | 2017/10/25    (V1.07)                   *
//*---------------------------------------------------------------------------*
//* TRIMSHEET中新增ALTERNATE CG線，判斷MACTOW 在CG線的哪一測，加註ALF/FWD CG  *
//*於Load sheet & ELS                                                         *
//*****************************************************************************
//* Thomas    | Ver. 03 | #BR17229  | 2018/1/23                               *
//*---------------------------------------------------------------------------*
//* 增加第二條ALTERNATE CG線 for 787                                          *
//*****************************************************************************
//* Thomas    | Ver. 04 | #BR18107  | 2018/5/4                                *
//*---------------------------------------------------------------------------*
//* 增加 AFT CG TAKEOFF for 787                                               *
//*****************************************************************************
//* Thomas    | Ver. 05 | #BR18110  | 2018/7/10                               *
//*---------------------------------------------------------------------------*
//* 增加 ZONE or ROW 787                                                      *
//*****************************************************************************
//* Thomas    | Ver.06 | #BR19011  | 2019/3/13                                *
//*---------------------------------------------------------------------------*
//* FDB在ZFW下新增LDWEL 、 LDWGT ，刪除NORMAL下的FWD，判斷LANDING WT <=195407 *
//* 時顯示LDWEL 的FWD 若 >195407 則顯示LWD的 FWD                              *
//*****************************************************************************
using System;
using System.Collections;
using System.Drawing;
using EWBS;
using EwbsCore.Util;
using info.lundin.Math;
using System.Collections.Generic;

namespace FlightDataBase
{
    /// <summary>
    /// StabilizerTrim
    /// </summary>
    public class StabilizerTrimItem
    {
        private string name; //Stablizer Trim Item Name
        private float index; //Stablizer Trim index

        /// <summary>
        /// Constructor
        /// </summary>
        public StabilizerTrimItem(string name, float index)
        {
            this.name = name;
            this.index = index;
        }
        
        /// <summary>
        /// Stablizer Trim Item Name
        /// </summary>
        public string Name
        {
            get { return name; }
            set { name = value; }
        }

        /// <summary>
        /// Stablizer Trim index
        /// </summary>
        public float Index
        {
            get { return index; }
            set { index = value; }
        }
    }

    //Weight Limitation
    public class WtLmt
    {
        private float fwdLmt; //forward limit
        private float aftLmt; //aft limit

        /// <summary>
        /// Constructor
        /// </summary>
        public WtLmt()
        {
            fwdLmt = 0;
            aftLmt = 0;
        }

        /// <summary>
        /// fwdLmt
        /// </summary>
        public float Fwd
        {
            get { return fwdLmt; }
            set { fwdLmt = value; }
        }

        /// <summary>
        /// aftLmt
        /// </summary>
        public float Aft
        {
            get { return aftLmt; }
            set { aftLmt = value; }
        }
    }

    /// <summary>
    /// Summary description for DerivedAirType.
    /// </summary>
    public class AirTypeEx
    {
        private string fullAirTypeName; //fullAirTypeName
        private Airtype theAirType; //airtype 
        private FuelDensity fuelDensity; //#BR19015
        public AirTypeEx(Airtype other)
        {
            theAirType = other;
        }

        #region Properties

        /// <summary>
        /// get AircraftInfomation Object
        /// </summary>
        public AircraftInfomation AircraftInfomation
        {
            get { return theAirType.AircraftInfomation; }
        }

        /// <summary>
        /// get AircraftConfiguration Object
        /// </summary>
        public AircraftConfiguration AircraftConfiguration
        {
            get { return theAirType.AircraftConfiguration; }
        }

        /// <summary>
        /// get TrimSheet Object
        /// </summary>
        public TrimSheet TrimSheet
        {
            get { return theAirType.TrimSheet; }
        }

        /// <summary>
        /// get SeatRowIndex Object
        /// </summary>
        public SeatRowIndex SeatRowIndex
        {
            get { return theAirType.SeatRowIndex; }
        }

        /// <summary>
        /// get ZonePantryIndex Object
        /// </summary>
        public ZonePantryIndex ZonePantryIndex
        {
            get { return theAirType.ZonePantryIndex; }
        }

        /// <summary>
        /// get PantryCode Object
        /// </summary>
        public PantryCode PantryCode
        {
            get { return theAirType.PantryCode; }
        }

        /// <summary>
        /// get CrewInfomation Object
        /// </summary>
        public CrewInfomation CrewInfomation
        {
            get { return theAirType.CrewInfomation; }
        }

        /// <summary>
        /// get CrewDistribution Object
        /// </summary>
        public CrewDistribution CrewDistribution
        {
            get { return theAirType.CrewDistribution; }
        }

        /// <summary>
        /// get FuelTank Object
        /// </summary>
        public FuelTank FuelTank
        {
            get { return theAirType.FuelTank; }
        }

        /// <summary>
        /// get FuelTankArm Object
        /// </summary>
        public AirtypeFuelTankArm FuelTankArm
        {
            get { return theAirType.FuelTankArm; }
        }

        /// <summary>
        /// get FuelFormula Object
        /// </summary>
        public FuelFormula FuelFormula
        {
            get { return theAirType.FuelFormula; }
        }

        /// <summary>
        /// get CargoFormula Object
        /// </summary>
        public CargoFormula CargoFormula
        {
            get { return theAirType.CargoFormula; }
        }

        /// <summary>
        /// get CargoInfomation Object
        /// </summary>
        public CargoInfomation CargoInfomation
        {
            get { return theAirType.CargoInfomation; }
        }

        /// <summary>
        /// get CargoPosition Object
        /// </summary>
        public CargoPosition CargoPosition
        {
            get { return theAirType.CargoPosition; }
        }

        /// <summary>
        /// get cpi Object
        /// </summary>
        public AirtypeCpi[] cpi
        {
            get
            {
                if (theAirType.cpi == null || theAirType.cpi[0].index == 0) return null;
                return theAirType.cpi;
            }
        }

        /// <summary>
        /// get Unsymmetrical Wt Limit Object
        /// </summary>
        public AirtypeUnsymmetrical[] asy
        {
            get { return theAirType.Unsymmetrical; }
        }

        //<!--#BR17203  THOMAS
        /// <summary>
        /// get  Object 
        /// </summary>
        public AirtypeLargePalletOverLap[] lpol
        {
            get { return theAirType.LargePalletOverLap; }
        }
        //#BR1720X3-->

        /// <summary>
        /// get AirType name
        /// </summary>
        public string name
        {
            get { return theAirType.name; }
        }

        /// <summary>
        /// get AirType description
        /// </summary>
        public string description
        {
            get { return theAirType.description; }
            set { theAirType.description = value; }
        }

        //#BR071001 <--  Auto Load Plan
        public AirtypeCargoVersion CargoVersion
        {
            get { return this.theAirType.CargoVersion; }
        }
        //-->
        #endregion

        #region Formula calculation

        /// <summary>Calculate Relative Index</summary>
        /// <param name="station">position座標</param>
        /// <param name="weight"> weight </param>
        /// <returns>Float: Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        private float CalcReltIndex(float station, float weight)
        {
            try
            {
                MACMacfor param = theAirType.MAC.macfor;
                return weight * (station - param.refStation) / param.constant;
            }
            catch
            {
                return float.NegativeInfinity;
            }
        }

        // compute %Mac公式
        //
        //          C．(I - K)
        //			----------- + Ref. Sta. - LEMAC
        //				  W
        //%MAC	=-------------------------------
        //						MAC
        //					  -------
        //						100
        //
        //W 		=	Weight, actual.
        //Sta.		=	Station, horizontal distance in inches from station zero to the location.
        //Ref. Sta.	=	Reference station/axis. Selected station around which all index values are calculated.
        //K		=	Constant used as a plus value to avoid negative index figures.
        //C		=	Constant used as a denominator to convert moment values into index values.
        //
        //I		=	Index value corresponding to respective weight.
        //MAC	=	Length of Mean Aerodynamic Chord in inches or metres.
        //LEMAC	=	Horizontal distance in inches from the station zero to location of the Leading Edge of the MAC.
        //

        /// <summary> compute Mac</summary>
        /// <param name="index"></param>
        /// <param name="weight"></param>
        /// <returns>Float: Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float CalcMac(float index, float weight)
        {
            try
            {
                MACMacfor param = theAirType.MAC.macfor;
                return (param.constant * (index - param.reduction) / weight + param.refStation - param.lemac) * 100 / param.mac;
            }
            catch
            {
                return float.NegativeInfinity;
            }
        }

        #endregion

        #region Index calculation

        /// <summary> compute fuel Index</summary>
        /// <param name="vars">tabk information</param>
        /// <param name="fuelDensity">fuel density</param>
        /// <returns>fuel Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float CalcFuelIndex(Hashtable vars, float fuelDensity)
        {
            float ttlIndex = 0;
            bool found = false;
            //Expression Parser
            ExpressionParser e = new ExpressionParser();

            //use tank  volume as parameter 
            foreach (FuelTankInfo tankInfo in theAirType.FuelTank.info)
            {
                object vol = vars[tankInfo.tank.ToLower()]; //tank  name shall be lower case

                if (vol == null)
                {
                    vars[tankInfo.tank.ToLower()] = "0";
                }
                else
                {
                    found = true;
                }
            }

            if (!found)
                return float.NegativeInfinity;

            try
            {
                // search tank ARM，and compute Index
                AirtypeFuelTankArmTank[] tanks = theAirType.FuelTankArm.tank;
                foreach (AirtypeFuelTankArmTank tank in tanks)
                {
                    //float idxTank=float.NegativeInfinity;
                    int i = 0;
                    float theArm = 0;

                    // Parse and write the result
                    double result = e.Parse(tank.name, vars);
                    for (i = 0; i < tank.arm.Length; i++)
                    {
                        if (result <= tank.arm[i].volume)
                            break;
                    }

                    if (i <= 0)
                    {
                        theArm = tank.arm[i].arm;
                    }
                    else if (i > 0 && i < tank.arm.Length)
                    {
                        float ratio = (float)(result - tank.arm[i - 1].volume) / (tank.arm[i].volume - tank.arm[i - 1].volume);
                        theArm = ratio * (tank.arm[i].arm - tank.arm[i - 1].arm) + tank.arm[i - 1].arm;
                    }
                    else
                    {
                        throw (new Exception(EWBSCoreWarnings.FDBUnReasonableTtlFuelWt));
                    }

                    ttlIndex += this.CalcReltIndex(theArm, (float)result * fuelDensity);
                }
                return ttlIndex;
            }
            catch
            {
                return float.NegativeInfinity;
            }
        }

        /// <summary> compute Crew Index</summary>
        /// <param name="_posn">position</param>
        /// <param name="_weight"> weight </param>
        /// <returns>Crew Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float CalcCrewIndex(string _posn, float _weight)
        {
            try
            {
                //Crew
                foreach (CrewInfomationInfo crewInfo in theAirType.CrewInfomation.info)
                {
                    if (_posn.ToLower().Equals(crewInfo.crewPos.ToLower()))
                    {
                        return _weight * crewInfo.index;
                    }
                } //foreach
            }
            catch
            {
            }
            return float.NegativeInfinity;
        }

        /// <summary> compute Galley Index</summary>
        /// <param name="_posn">position</param>
        /// <param name="_weight"> weight </param>
        /// <returns>Galley Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float CalcGalleyIndex(string _posn, float _weight)
        {
            try
            {
                //Galley
                foreach (ZonePantryIndexGalleyGinfo galleyInfo in theAirType.ZonePantryIndex.galley.ginfo)
                {
                    if (_posn.ToLower().Equals(galleyInfo.id.ToLower()))
                    {
                        return (_weight * galleyInfo.index);
                    }
                } //foreach
            }
            catch
            {
            }
            return float.NegativeInfinity;
        }

        /// <summary> compute Seat Index</summary>
        /// <param name="_posn">position</param>
        /// <param name="_weight"> weight </param>
        /// <returns>Seat Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float CalcSeatIndex(string _posn, float _weight)
        {
            try
            {
                //check seat finally
                string rowno = _posn;
                for (int i = rowno.Length; --i >= 0 && !Char.IsNumber(rowno[i]); rowno = rowno.Substring(0, i)) ;
                int theRowNo = Convert.ToInt32(rowno);
                foreach (SeatRowIndexInfo seatInfo in theAirType.SeatRowIndex.info)
                {
                    if (Convert.ToInt32(seatInfo.row) == theRowNo)
                    {
                        return (_weight * seatInfo.index);
                    } //
                } //foreach
            }
            catch
            {
            }

            return float.NegativeInfinity;
        }

        /// <summary> compute Zone Index</summary>
        /// <param name="_posn">position</param>
        /// <param name="_weight"> weight </param>
        /// <returns>Zone Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public double CalcZoneIndex(string _posn, double _weight)
        {
            try
            {
                return (_weight * GetZoneInfo(_posn).index);
            }
            catch
            {
            }
            return double.NegativeInfinity;
        }

        /// <summary> get Cabin Configurations</summary>
        /// <returns>Cabin Configurations</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string[] GetCabinConfigurationStrings()
        {
            ArrayList aList = new ArrayList();
            // Cabin Configuration of the flight
            // seatplan[i].name is Cabin Configuration  string (such as "8F/16C/248Y")
            for (int i = 0; i < theAirType.CabinConfiguration.seatplan.Length; i++)
                aList.Add(theAirType.CabinConfiguration.seatplan[i].name.Trim());

            // Get the Cabin Configuration string and add to ComboBox
            return (string[])aList.ToArray(typeof(string));
        }

        /// <summary> get SeatPlan data </summary>
        /// <param name="cabinCFG">Cabin Configuration</param>
        /// <returns>Seat Plan</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public CabinConfigurationSeatplan GetSeatplan(string cabinCFG)
        {
            if (theAirType.CabinConfiguration != null)
            {
                cabinCFG = cabinCFG.Replace(" ", "");
                //confirm the to be used CabinConfiguration
                foreach (CabinConfigurationSeatplan seatplan in theAirType.CabinConfiguration.seatplan)
                {
                    if (seatplan.name.Replace(" ", "").ToLower().Equals(cabinCFG.ToLower()) || cabinCFG == "")
                    {
                        return seatplan;
                    }
                } //foreach

                if (theAirType.CabinConfiguration.seatplan.Length > 0)
                    return theAirType.CabinConfiguration.seatplan[0];
            }
            return null;
        }

        #endregion

        #region Trim relative methods
      
        /// <summary> search the ideal Trim</summary>
        /// <param name="refWt">reference weight </param>
        /// <returns>Float: Trim</returns></returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float FindIdealTrim(float refWt)
        {
            float result = 0f;
            try
            {
                foreach (TrimSheetWeight wtLmt in theAirType.TrimSheet.weight)
                {
                    if (wtLmt.name.ToUpper().Equals("ZFW")) 
                    {
                        foreach (TrimSheetWeightCtrlcode ctrlCode in wtLmt.ctrlcode)
                        {
                            //check if Ctrl Code=="IDEAL" or not
                            if (ctrlCode.name.ToUpper().Equals("IDEAL"))
                            {
                                foreach (TrimSheetWeightCtrlcodeLimit lmt in ctrlCode.limit)
                                {
                                    //use linear to compute Ideal Trim
                                    int i;
                                    for (i = 0; i < lmt.point.Length; i++)
                                    {
                                        if (refWt <= lmt.point[i].weight) break;
                                    }
                                    if (i == 0)
                                    {
                                        result = lmt.point[i].index;
                                    }
                                    else if (i < lmt.point.Length)
                                    {
                                        float ratio = (refWt - lmt.point[i - 1].weight) / (lmt.point[i].weight - lmt.point[i - 1].weight);
                                        result = ratio * (lmt.point[i].index - lmt.point[i - 1].index) + lmt.point[i - 1].index;
                                    }
                                } //for
                            }
                        } //for
                    }
                } //for
            }
            catch
            {
            }
            return (float)Math.Round(result, 1);
        }

        /// <summary>
        /// #BR18110 Thomas
        /// </summary>
        /// <param name="refWt"></param>
        /// <returns></returns>
        public float FindIdealTrimZone(float refWt)
        {
            float result = 0f;
            try
            {
                foreach (TrimSheetWeight wtLmt in theAirType.TrimSheet.weight)
                {
                    if (wtLmt.name.ToUpper().Equals("ZFW_ZONE"))
                    {
                        foreach (TrimSheetWeightCtrlcode ctrlCode in wtLmt.ctrlcode)
                        {
                            //check if Ctrl Code=="IDEAL" or not
                            if (ctrlCode.name.ToUpper().Equals("IDEAL"))
                            {
                                foreach (TrimSheetWeightCtrlcodeLimit lmt in ctrlCode.limit)
                                {
                                    //use linear to compute Ideal Trim
                                    int i;
                                    for (i = 0; i < lmt.point.Length; i++)
                                    {
                                        if (refWt <= lmt.point[i].weight) break;
                                    }
                                    if (i == 0)
                                    {
                                        result = lmt.point[i].index;
                                    }
                                    else if (i < lmt.point.Length)
                                    {
                                        float ratio = (refWt - lmt.point[i - 1].weight) / (lmt.point[i].weight - lmt.point[i - 1].weight);
                                        result = ratio * (lmt.point[i].index - lmt.point[i - 1].index) + lmt.point[i - 1].index;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
            }
            return (float)Math.Round(result, 1);
        }  

        /// <summary> search weight  restriction of ZFW</summary>
        /// <param name="_theFlight">Flight</param>
        /// <param name="_zfw">ZFW</param>
        /// <returns>WtLmt:  weight  restrict </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public WtLmt FindZFWTrim(Flight _theFlight, float _zfw)
        {
            //<!--#BR18110 787
            if (System.Configuration.ConfigurationManager.AppSettings["RowZoneMode"] == "Y")
            {
                if (_theFlight.Pax.BTrimByZone)
                {
                    return findWeightTrim(_theFlight, "ZFW_ZONE", _zfw);
                }
                else
                {
                    return findWeightTrim(_theFlight, "ZFW", _zfw);
                }
            }
            else
            {
                return findWeightTrim(_theFlight, "ZFW", _zfw); 
            }
            //return findWeightTrim(_theFlight, "ZFW", _zfw); 
            //#BR18110-->
        } 

        /// <summary> search weight  restriction of TOW</summary>
        /// <param name="_theFlight">Flight</param>
        /// <param name="_tow">TOW</param>
        /// <returns>WtLmt:  weight  restrict </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public WtLmt FindTOWTrim(Flight _theFlight, float _tow)
        {
            //<!--#BR18110 787
            if (System.Configuration.ConfigurationManager.AppSettings["RowZoneMode"] == "Y")
            {
                if (_theFlight.Pax.BTrimByZone)
                {
                    return findWeightTrim(_theFlight, "TOW_ZONE", _tow);
                }
                else
                {
                    return findWeightTrim(_theFlight, "TOW", _tow);
                }
            }
            else
            {
               return findWeightTrim(_theFlight, "TOW", _tow); 
            }
            //return findWeightTrim(_theFlight, "TOW", _tow); 
 
            //#BR18110-->
        } 

        /// <summary> searchWeight Trim</summary>
        /// <param name="theFlight">Flight</param>
        /// <param name="nmWtLmt"> weight  restrict  name </param>
        /// <param name="refWt">reference weight </param>
        /// <returns>WtLmt: Weight Limit data </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        private WtLmt findWeightTrim(Flight theFlight, string nmWtLmt, float refWt)
        {
            WtLmt result = new WtLmt();
            try
            {
                string[] FwdAftList = new string[] { "FWD", "AFT" };

                foreach (string fwdaft in FwdAftList)
                {
                    TrimSheetWeightCtrlcodeLimit lmt = findTrimSheetWeightCtrlcodeLimit(theFlight, nmWtLmt, fwdaft);
                    if (lmt != null)
                    {
                        //find fwd limit
                        if (lmt.name.Equals("FWD"))
                        {
                            int i;
                            for (i = 0; i < lmt.point.Length; i++)
                            {
                                if (refWt <= lmt.point[i].weight) break;
                            }
                            if (i == 0)
                            {
                                result.Fwd = lmt.point[i].index;
                            }
                            else if (i < lmt.point.Length)
                            {
                                float ratio = (refWt - lmt.point[i - 1].weight) / (lmt.point[i].weight - lmt.point[i - 1].weight);
                                result.Fwd = ratio * (lmt.point[i].index - lmt.point[i - 1].index) + lmt.point[i - 1].index;
                            }
                        }
                        //find Aft limit
                        if (lmt.name.Equals("AFT"))
                        {
                            int i;
                            for (i = 0; i < lmt.point.Length; i++)
                            {
                                if (refWt <= lmt.point[i].weight) break;
                            }
                            if (i == 0)
                            {
                                result.Aft = lmt.point[i].index;
                            }
                            else if (i < lmt.point.Length)
                            {
                                float ratio = (refWt - lmt.point[i - 1].weight) / (lmt.point[i].weight - lmt.point[i - 1].weight);
                                result.Aft = ratio * (lmt.point[i].index - lmt.point[i - 1].index) + lmt.point[i - 1].index;
                            }
                        }
                    }
                } //FWD/AFT
            }
            catch
            {
            }
            result.Fwd = (float)Math.Round(result.Fwd, 1);
            result.Aft = (float)Math.Round(result.Aft, 1);

            return result;
        }

        /// <summary> search  weight range area</summary>
        /// <param name="theFlight">Flight</param>
        /// <param name="nmWtLmt"> weight  restrict  name </param>
        /// <returns>Point[]: array of covered area</returns>
        /// <remarks>  
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// BR09113 public Point[] findWeightTrimRegion(Flight theFlight, string nmWtLmt)
        /// </remarks>
        public PointF[] findWeightTrimRegion(Flight theFlight, string nmWtLmt)
        {
            ArrayList points = new ArrayList();
            try
            {
                string[] FwdAftList = new string[] { "FWD", "AFT" };

                foreach (string fwdaft in FwdAftList)
                {
                    TrimSheetWeightCtrlcodeLimit lmt = findTrimSheetWeightCtrlcodeLimit(theFlight, nmWtLmt, fwdaft);

                    if (lmt != null)
                    {
                        if (lmt.name.Equals("FWD")) //Forward
                        {
                            for (int i = 0; i < lmt.point.Length; i++)
                            {
                                //BR09113 points.Add(new Point(Convert.ToInt32(lmt.point[i].index),Convert.ToInt32(lmt.point[i].weight)));
                                points.Add(new PointF(lmt.point[i].index,lmt.point[i].weight));  //BR09113
                            }
                        }
                       
                        else if (lmt.name.Equals("AFT")) //Afterward
                        {
                            for (int i = lmt.point.Length - 1; i >= 0; i--)
                            {
                                //BR09113 points.Add(new Point(Convert.ToInt32(lmt.point[i].index),Convert.ToInt32(lmt.point[i].weight)));
                                points.Add(new PointF(lmt.point[i].index,lmt.point[i].weight));  //BR09113
                            }
                        }
                    }
                } //FWD/AFT
            }
            catch
            {
            }
            //BR09113 return (Point[]) points.ToArray(typeof (Point));
            return (PointF[])points.ToArray(typeof(PointF));  //BR09113
        }

        /// <summary> search Trim Sheet Weight Control code Limit </summary>
        /// <param name="theFlight">Flight</param>
        /// <param name="nmWtLmt"> weight restriction name </param>
        /// <param name="fwdAft">Fwd or Aft</param>
        /// <returns>TrimSheetWeightCtrlcodeLimit</returns>
        private TrimSheetWeightCtrlcodeLimit findTrimSheetWeightCtrlcodeLimit(Flight theFlight, string nmWtLmt, string fwdAft)
        {
            //search weight restriction by name 
            foreach (TrimSheetWeight wtLmt in theAirType.TrimSheet.weight)
            {
                if (wtLmt.name.ToUpper().Equals(nmWtLmt.ToUpper())) //found
                {
                    for (int ctrlIndex = wtLmt.ctrlcode.Length - 1; ctrlIndex >= 0; ctrlIndex--)
                    {
                        TrimSheetWeightCtrlcode ctrlCode = wtLmt.ctrlcode[ctrlIndex];
                        //check Ctrl Code								
                        
                        if (ctrlCode.name.ToUpper() != "IDEAL" && parseCtrlCode(theFlight, ctrlCode)) 
                        {
                            foreach (TrimSheetWeightCtrlcodeLimit lmt in ctrlCode.limit)
                            {
                                if (lmt.name.Equals(fwdAft)) //Fwd or Aft?
                                {
                                    return lmt;
                                }
                            } 
                        }
                    } 
                }
            }
            return null;
        }
        
        /// <summary>
        /// //#BR17208  THOMAS 畫ALTERNATE LINE
        /// </summary>
        /// <param name="theFlight"></param>
        /// <param name="nmWtLmt"></param>
        /// <returns></returns>
        public PointF[] findALTERNATETrimLine(Flight theFlight, string nmWtLmt, string LineName = "")
        {
            ArrayList points = new ArrayList();
            try
            {
                string[] LineList = new string[] { "FWD" };
                foreach (string line in LineList)
                {
                    TrimSheetWeightCtrlcodeLimit lmt = findTrimSheetCtrlcodeALTERNATE(theFlight, nmWtLmt, line, LineName); 
                    if (lmt != null)
                    {
                        if (lmt.name.Equals("FWD"))
                        {
                            for (int i = 0; i < lmt.point.Length; i++)
                            {
                                points.Add(new PointF(lmt.point[i].index, lmt.point[i].weight));
                            }
                        }
                    }
                }
            }
            catch { }
            return (PointF[])points.ToArray(typeof(PointF));
        } 

        /// <summary>
        /// //#BR17208  THOMAS 畫TOW_ALTFWDCG
        /// </summary>
        /// <param name="theFlight"></param>
        /// <param name="nmWtLmt"></param>
        /// <param name="line"></param>
        /// <returns></returns>
        private TrimSheetWeightCtrlcodeLimit findTrimSheetCtrlcodeALTERNATE(Flight theFlight, string nmWtLmt, string line, string LineName ="")
        {
            foreach (TrimSheetWeight wtLmt in theAirType.TrimSheet.weight)
            {
                if (wtLmt.name.ToUpper().Equals(nmWtLmt.ToUpper())) //found
                {
                    for (int ctrlIndex = wtLmt.ctrlcode.Length - 1; ctrlIndex >= 0; ctrlIndex--)
                    {
                        TrimSheetWeightCtrlcode ctrlCode = wtLmt.ctrlcode[ctrlIndex];
                      				
                        if (ctrlCode.name.ToUpper() == LineName && parseCtrlCode(theFlight, ctrlCode))  //check Ctrl Code				
                        {
                            foreach (TrimSheetWeightCtrlcodeLimit lmt in ctrlCode.limit)
                            {
                                if (lmt.name.Equals(line)) 
                                {
                                    return lmt;
                                }
                            } //for
                        }
                    } //for
                }
            } //for
            return null;
        } 

        /// <summary>
        /// /#BR18107  THOMAS 取AFT CG TAKEOFF座標
        /// </summary>
        /// <param name="theFlight"></param>
        /// <param name="nmWtLmt"></param>
        /// <param name="AreaName"></param>
        /// <returns></returns>
        public PointF[] findEXPDAREATrimLine(Flight theFlight, string nmWtLmt, string AreaName = "")
        {
            ArrayList points = new ArrayList();
            try
            {
                string[] LineList = new string[] { "FWD", "AFT" };
                foreach (string line in LineList)
                {
                    TrimSheetWeightCtrlcodeLimit lmt = findTrimSheetCtrlcodeEXPD(theFlight, nmWtLmt, line, AreaName);
                    if (lmt != null)
                    {
                        if (lmt.name.Equals("FWD"))
                        {
                            for (int i = 0; i < lmt.point.Length; i++)
                            {
                                points.Add(new PointF(lmt.point[i].index, lmt.point[i].weight));
                            }
                        }
                        else if (lmt.name.Equals("AFT"))
                        {
                            for (int i = lmt.point.Length - 1; i >= 0; i--)
                            {
                                points.Add(new PointF(lmt.point[i].index, lmt.point[i].weight));
                            }
                        }
                    }
                }
            }
            catch { }
            return (PointF[])points.ToArray(typeof(PointF));
        } 

        /// <summary>
        /// //#BR18107  THOMAS 取AFT CG TAKEOFF 座標
        /// </summary>
        /// <param name="theFlight"></param>
        /// <param name="nmWtLmt"></param>
        /// <param name="line"></param>
        /// <returns></returns>
        private TrimSheetWeightCtrlcodeLimit findTrimSheetCtrlcodeEXPD(Flight theFlight, string nmWtLmt, string line, string AreaName = "")
        {
            foreach (TrimSheetWeight wtLmt in theAirType.TrimSheet.weight)
            {
                if (wtLmt.name.ToUpper().Equals(nmWtLmt.ToUpper())) //found
                {
                    for (int ctrlIndex = wtLmt.ctrlcode.Length - 1; ctrlIndex >= 0; ctrlIndex--)
                    {
                        TrimSheetWeightCtrlcode ctrlCode = wtLmt.ctrlcode[ctrlIndex];

                        if (ctrlCode.name.ToUpper() == AreaName && parseCtrlCode(theFlight, ctrlCode))  //check Ctrl Code				
                        {
                            foreach (TrimSheetWeightCtrlcodeLimit lmt in ctrlCode.limit)
                            {
                                if (lmt.name.Equals(line))
                                {
                                    return lmt;
                                }
                            } //for
                        }
                    } //for
                }
            } //for
            return null;
        }

        /// <summary>
        /// 判斷是否啟用CTRLCODE
        /// </summary>
        /// <param name="theFlight"></param>
        /// <param name="_ctrlCode"></param>
        /// <returns></returns>
        private bool parseCtrlCode(Flight theFlight, TrimSheetWeightCtrlcode _ctrlCode)
        {
            //conditional switch
            //<ctrlcode name="IDEAL" argumet="0">
            //<ctrlcode name="INCRE" argumet="0">
            //<ctrlcode name="NORMAL" argumet="0">
            //<ctrlcode name="NORMAL" argumet="38">
            //<ctrlcode name="TAILF" argumet="0">
            //<ctrlcode name="ZFWGE" argumet="119900">
            //<ctrlcode name="ZFWGT" argumet="247207">
            //<ctrlcode name="ZFWGT" argumet="28700">
            //<ctrlcode name="ZFWGT" argumet="33000">
            //<ctrlcode name="ZFWLE" argumet="28700">
            //<ctrlcode name="ZFWLE" argumet="33000">
            try
            {
                switch (_ctrlCode.name.ToUpper())
                {
                    //IDEAL TRIM
                    case "IDEAL":
                        break;
                    //Increased cumulative load
                    case "INCRE":
                        return theFlight.UsingIncreasedCumulativeLoad && (theFlight.Fuel.TailFuel == 0);
                    //TOW
                    case "NORMAL":
                        return true;
                    //with Tail tank
                    case "TAILF":
                        return theFlight.Fuel.TailFuel > 0;
                    //ZFW
                    case "ZFWGE":
                        return theFlight.ZFW >= Convert.ToSingle(_ctrlCode.argumet);
                    case "ZFWGT":
                        return theFlight.ZFW > Convert.ToSingle(_ctrlCode.argumet);
                    case "ZFWLE":
                        return theFlight.ZFW <= Convert.ToSingle(_ctrlCode.argumet);
                    case "ZFWLT":
                        return theFlight.ZFW < Convert.ToSingle(_ctrlCode.argumet);
                    case "LDWLE":  //#BR19011 新增 LDWLE ，於 LANDING WT <=195407 時顯示
                        return theFlight.LDW <= Convert.ToSingle(_ctrlCode.argumet);
                    case "LDWGT":  //#BR19011 新增 LDWGT ，於 LANDING WT >195407 時顯示
                        return theFlight.LDW > Convert.ToSingle(_ctrlCode.argumet); ;
                    //Takeoff Fuel
                    case "TOFGE":
                        return theFlight.Fuel.TakeoffFuel >= Convert.ToSingle(_ctrlCode.argumet);
                    case "TOFGT":
                        return theFlight.Fuel.TakeoffFuel > Convert.ToSingle(_ctrlCode.argumet);
                    case "TOFLE":
                        return theFlight.Fuel.TakeoffFuel <= Convert.ToSingle(_ctrlCode.argumet);
                    case "TOFLT":
                        return theFlight.Fuel.TakeoffFuel < Convert.ToSingle(_ctrlCode.argumet);
                    //Fuel Density
                    case "DENGE":
                        return theFlight.Fuel.RampFuel >= Convert.ToSingle(_ctrlCode.argumet);
                    case "DENGT":
                        return theFlight.Fuel.RampFuel > Convert.ToSingle(_ctrlCode.argumet);
                    case "DENLE":
                        return theFlight.Fuel.RampFuel <= Convert.ToSingle(_ctrlCode.argumet);
                    case "DENLT":
                        return theFlight.Fuel.RampFuel < Convert.ToSingle(_ctrlCode.argumet);
                    //TOW_ALTFWDCG
                    case "ALTERNATE1":  //#BR17208 THOMAS 增加 ALTERNATE 1 for 777
                        return true;
                    case "ALTERNATE2":  //#BR17229 THOMAS 增加第二條ALTERNATE CG  for 787 
                        return true;
                    //AFT CG TAKEOFF
                    case "AFT_CG":  //#BR18107 THOMAS 增加AFT_CG 787 
                        return true;

                }
                return false;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        /// <summary>
        /// Airyype name includes Carrier Code
        /// </summary>
        public string FullAirTypeName
        {
            get { return fullAirTypeName; }
            set { fullAirTypeName = value; }
        }

        //#BR19015
        public FuelDensity FuelDensity
        {
            get { return fuelDensity; }
            set { fuelDensity = value; }
        }

        /// <summary>
        /// get trim sheet image
        /// </summary>
        public Image TrimSheetImage
        {
            get
            {
                try
                {
                    if (fullAirTypeName != null)
                    {
                        string strImgName = FileFinder.GetFileName(fullAirTypeName + "TrimSheet.jpg");
                        return Image.FromFile(strImgName);
                    }
                }
                catch
                {
                }
                return null;
            }
        }

        /// <summary>
        /// #BR18110
        /// </summary>
        public Image TrimSheetImageZone
        {
            get
            {
                try
                {
                    if (fullAirTypeName != null)
                    {
                        string strImgName = FileFinder.GetFileName(fullAirTypeName + "TrimSheetZone.jpg");
                        return Image.FromFile(strImgName);
                    }
                }
                catch
                {
                }
                return null;
            }
        }

        /// <summary>
        /// get CG Lmt For Lateral
        /// </summary>
        public AirtypeCGLmtForLateral CGLmtForLateral
        {
            get { return theAirType.CGLmtForLateral; }
        }

        /// <summary> get Water Weight</summary>
        /// <param name="percetage">percetage of water</param>
        /// <returns>Float:  weight </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float GetWaterWt(float percetage)
        {
            float wt = 0f;
            foreach (AirtypeTank wtank in theAirType.WaterTank)
            {
                wt += wtank.wt * percetage;
            }
            return (float)Math.Round(wt, 1);
        }

        /// <summary> get Water Index</summary>
        /// <param name="percetage">percetage of water tank</param>
        /// <returns>Float: Index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public float GetWaterIdx(float percetage)
        {
            float idx = 0f;
            foreach (AirtypeTank wtank in theAirType.WaterTank)
            {
                idx += this.CalcReltIndex(wtank.arm, wtank.wt * percetage);
            }
            return idx;
        }

        /// <summary> get the restriction of Max. mumber of people for the Cabin Configuration </summary>
        /// <param name="cabinCFG">cabin configuration</param>
        /// <returns>Max. mumber of people in each classes</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public ClsDstnClassItem GetMaxSeatCabinConfiguration(string cabinCFG)
        {
            ClsDstnClassItem result = new ClsDstnClassItem("Max");
            try
            {
                int[] aList = FlightUtil.GetPaxArrayFromCabinConfiguarion(cabinCFG);
                for (int i = 0; i < 3 && i < aList.Length; i++)
                    result[i] = aList[i];
            }
            catch
            {
            }
            return result;
        }

        /// <summary>Convert Seat data into Row data </summary>
        /// <param name="seatCd">seat code</param>
        /// <returns>int: Row Number</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        /// 將座位轉為行數
        public int Seat2Row(string seatCd)
        {
            string row = seatCd + ".";
            for (int i = 0; i < seatCd.Length; i++)
            {
                if (!char.IsDigit(seatCd, i))
                {
                    row = seatCd.Substring(0, i);
                }
            }
            if (row != "") return Convert.ToInt32(row);

            throw (new Exception(string.Format(EWBSCoreWarnings.FDBCantConvertSeatCdToZone_1, seatCd)));
        }

        /// <summary>Get Zone data by Zone name</summary>
        /// <param name="znName">Zone Name</param>
        /// <returns>ZonePantryIndexZoneZinfo</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public ZonePantryIndexZoneZinfo GetZoneInfo(string znName)
        {
            foreach (ZonePantryIndexZoneZinfo znInfo in this.ZonePantryIndex.zone.zinfo)
            {
                if (znInfo.id.Equals(znName))
                    return znInfo;
            }
            //Not Found
            throw (new Exception(string.Format(EWBSCoreWarnings.FDBZoneNotFound_1, znName)));
        }

        /// <summary>get Cabin Class data by Class name and seat plan </summary>
        /// <param name="seatplan">seat plan</param>
        /// <param name="NmCls">Name of Class</param>
        /// <returns>CabinConfigurationSeatplanInfo</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public CabinConfigurationSeatplanInfo GetCabinClassInfo(CabinConfigurationSeatplan seatplan, string NmCls)
        {
            if (seatplan != null)
            {
                //get Class by Zone
                for (int i = 0; i < seatplan.info.Length; i++)
                {
                    CabinConfigurationSeatplanInfo seatplanInfo = seatplan.info[i];

                    if (seatplanInfo.@class.ToUpper().IndexOf(NmCls) >= 0)
                    {
                        return seatplanInfo; //Found
                    }
                }
            }
            //Not Found
            throw (new Exception(string.Format(EWBSCoreWarnings.FDBCabinClsNotFound, NmCls)));
        }

        /// <summary>Convert Row's data into Zone</summary>
        /// <param name="row">row number</param>
        /// <returns>string: Zone name</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string Row2ZoneNm(int row)
        {
            //get Zone by Row
            foreach (SeatRowIndexInfo info in theAirType.SeatRowIndex.info)
            {
                if (info.row == row)
                {
                    return info.zone.ToUpper();
                }
            } 
            //Not Found
            throw (new Exception(string.Format(EWBSCoreWarnings.FDBCantConvertRowToCls_1, row)));
        }

        /// <summary>
        /// Convert Row's data into Class
        /// </summary>
        /// <param name="cabinCFG"></param>
        /// <param name="row"></param>
        /// <returns>0: first class /1: second class /2: last class /-1:not found</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public int Row2Class(string cabinCFG, int row)
        {
            try
            {
                //get Zone by Row
                string zoneNm = Row2ZoneNm(row);
                return Zone2Class(cabinCFG, zoneNm);
            }
            catch
            {
                //Not Found
                throw (new Exception(string.Format(EWBSCoreWarnings.FDBCantConvertRowToCls_1, row)));
            }
        }

        /// <summary>
        /// Convert Zone data into Class
        /// </summary>
        /// <param name="cabinCFG"></param>
        /// <param name="zoneNm"></param>
        /// <returns>0: first class /1: second class /2: last class /-1:not found</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public int Zone2Class(string cabinCFG, string zoneNm)
        {
            //get the right Cabin configuration
            CabinConfigurationSeatplan seatplan = this.GetSeatplan(cabinCFG);
            if (seatplan != null)
            {
                ArrayList ClassNames = FlightUtil.GetClassNamesFromCabinConfiguarion(cabinCFG);
                //get Zone by Row
                for (int i = 0; i < ClassNames.Count; i++)
                {
                    CabinConfigurationSeatplanInfo seatplanInfo = this.GetCabinClassInfo(seatplan, ClassNames[i] as String);

                    if (seatplanInfo.zones.ToUpper().IndexOf(zoneNm) >= 0)
                    {
                        return i; //Found
                    }
                }
            }
            //Not Found
            throw (new Exception(string.Format(EWBSCoreWarnings.FDBBadZoneNameOrCabinConfig_2, zoneNm, cabinCFG)));
        }

        /// <summary> compute Cargo Index</summary>
        /// <param name="_posn">position</param>
        /// <param name="_baseCd">base code</param>
        /// <param name="_weight"> weight </param>
        /// <returns>double: index</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public double CalcCargoIndex(string _posn, string _baseCd, double _weight)
        {
            //foreach Hold, Compartment, Bay and Posn
            foreach (CargoPositionHold hld in this.CargoPosition.hold)
            {
                foreach (CargoPositionHoldCmp cmp in hld.cmp)
                {
                    foreach (CargoPositionHoldCmpBay bay in cmp.bay)
                    {
                        foreach (CargoPositionHoldCmpBayPos posn in bay.pos)
                        {
                            if (posn.name.ToUpper().Equals(_posn.ToUpper()))
                            {
                                //Base Code
                                foreach (CargoPositionHoldCmpBayPosBaseCode baseCd in posn.baseCode)
                                {
                                    if (baseCd.name.ToUpper().Equals(_baseCd.ToUpper()))
                                        return _weight * baseCd.index;
                                } 
                                break;
                            }
                        } 
                    } 
                } 
            } 
            return double.NegativeInfinity;
        }
        
        /// <summary>
        ///  Whether DLW Limitation exists
        /// </summary>
        public bool IsDLW
        {
            get
            {
                if (theAirType.TrimSheet != null)
                {
                    foreach (TrimSheetWeight wtNm in theAirType.TrimSheet.weight)
                        if (wtNm.name.ToUpper() == "DLW") return true;
                } 
                return false;
            }
        }

        #region Stabilizer Trim Methods

        /// <summary>Find Stabilizer Trim</summary>
        /// <param name="inflection">Takeoff Trims Inflection</param>
        /// <param name="mactow">MACTOW</param>
        /// <returns>Float: Stabilizer Trim</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        private float findStabilizerTrim(AirtypeStabilizerTakeoffTrimsInflection inflection, float mactow)
        {
            try
            {
                AirtypeStabilizerTakeoffTrimsInflectionPoint pt;
                switch (inflection.point.Length)
                {
                    case 0:
                        return float.NegativeInfinity;
                    case 1:
                        pt = inflection.point[0];

                        if (mactow == pt.cg)
                        {
                            //found exactual trim
                            return pt.trim;
                        }
                        else
                        {
                            //not found
                            return float.NegativeInfinity;
                        }
                    default:
                        //calculate linear trim
                        for (int candidate = 0; candidate < inflection.point.Length; candidate++)
                        {
                            pt = inflection.point[candidate];
                            if (mactow <= pt.cg) //found
                            {
                                if (mactow == pt.cg)
                                {
                                    //found exactual trim
                                    return pt.trim;
                                }
                                else if (candidate == 0)
                                {
                                    //not found
                                    return float.NegativeInfinity;
                                }
                                else
                                {
                                    //calculate linear trim
                                    AirtypeStabilizerTakeoffTrimsInflectionPoint pre = inflection.point[candidate - 1];
                                    float ratio = (mactow - pre.cg) / (pt.cg - pre.cg);
                                    return ratio * (pt.trim - pre.trim) + pre.trim;
                                }
                            }
                        } 
                        break;
                } 
            }
            catch
            {
            }
            return float.NegativeInfinity;
        }

        /// <summary> get Stablizer Trim Item</summary>
        /// <param name="tow">TOW</param>
        /// <param name="mactow">MACTOW</param>
        /// <returns> StabilizerTrimItem[]</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public StabilizerTrimItem[] StabilizerTrim(float tow, float mactow)
        {
            ArrayList trimList = new ArrayList();
            try
            {
                //generate StabilizerTrim output for each thrust-flap
                foreach (AirtypeStabilizerTakeoffTrims theTrim in theAirType.Stabilizer.TakeoffTrims)
                {
                    float index = float.NegativeInfinity;

                    //calculate stabilizer trim
                    switch (theTrim.Inflection.Length)
                    {
                        case 0:
                            break;
                        case 1: //for example, A330-200, ignore tow.
                            index = findStabilizerTrim(theTrim.Inflection[0], mactow); //find max/actual trim by cg
                            break;
                        default:
                            //calculate linear trim by tow
                            for (int candidate = 0; candidate < theTrim.Inflection.Length; candidate++)
                            {
                                AirtypeStabilizerTakeoffTrimsInflection inflection = theTrim.Inflection[candidate];
                                float maxWt = Convert.ToSingle(inflection.grossWt) * Convert.ToSingle(inflection.scale);
                                if (tow <= maxWt) //found
                                {
                                    float maxIndex = findStabilizerTrim(inflection, mactow); //find max/actual trim by cg
                                    if (tow == maxWt)
                                    {
                                        index = maxIndex;
                                    }
                                    else if (candidate == 0)
                                    {
                                        //index=maxIndex;
                                    }
                                    else
                                    {
                                        //calculate linear trim by cg
                                        AirtypeStabilizerTakeoffTrimsInflection pre = theTrim.Inflection[candidate - 1];
                                        float minWt = Convert.ToSingle(pre.grossWt) * Convert.ToSingle(pre.scale);
                                        float minIndex = findStabilizerTrim(pre, mactow); //find min trim by cg
                                        float ratio = (tow - minWt) / (maxWt - minWt);
                                        //calculate index linearly
                                        index = ratio * (maxIndex - minIndex) + minIndex;
                                    }
                                    break;
                                }
                            }
                            break;
                    } 

                    if (index >= 0)
                    {
                        //Adjust the stabilizer trim
                        index += theTrim.adj_unit;
                        //limit the stabilizer trim
                        if (index > theTrim.max_unit) index = theTrim.max_unit;

                        //generate describtion
                        string desc;
                        if (theTrim.flap.Length > 0)
                        {
                            desc = theTrim.thrust + ", " + theTrim.flap;
                        }
                        else
                        {
                            desc = theTrim.thrust;
                        }

                        //Add it into Array
                        trimList.Add(new StabilizerTrimItem(desc.Trim(), index));
                    }
                } 
            }
            catch
            {
            }
            return (StabilizerTrimItem[])trimList.ToArray(typeof(StabilizerTrimItem));
        }

        #endregion

        #region Load Version Methods

        /// <summary>get defualt Load Version</summary>
        /// <returns>defualt Load version</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public AirtypeCargoVersionLoadVersion GetDefaultLoadVersion()
        {
            if (theAirType.CargoVersion != null && theAirType.CargoVersion.LoadVersion.Length > 0)
            {
                return theAirType.CargoVersion.LoadVersion[0];
            }
            return null;
        }

        /// <summary>get Load Version</summary>
        /// <param name="loadVersion">loadVersion string</param>
        /// <returns>Load Version object</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public AirtypeCargoVersionLoadVersion GetLoadVersion(string loadVersion)
        {
            if (theAirType.CargoVersion != null)
            {
                foreach (AirtypeCargoVersionLoadVersion ver in theAirType.CargoVersion.LoadVersion)
                {
                    if (ver.name.Equals(loadVersion)) return ver;
                }
            }
            return null;
        }

        /// <summary> get all of the Load version's name </summary>
        /// <returns>all of the Load version's name </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string[] GetLoadVersionNames()
        {
            ArrayList aList = new ArrayList();
            if (theAirType.CargoVersion != null)
            {
                foreach (AirtypeCargoVersionLoadVersion ver in theAirType.CargoVersion.LoadVersion)
                    aList.Add(ver.name);
            }
            return (string[])aList.ToArray(typeof(string));
        }

        /// <summary> get Load version description</summary>
        /// <param name="loadVersion">Load version name  string </param>
        /// <returns>Load version description</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string LoadVersionDescription(string loadVersion)
        {
            if (theAirType.CargoVersion != null)
            {
                foreach (AirtypeCargoVersionLoadVersion ver in theAirType.CargoVersion.LoadVersion)
                {
                    if (ver.name.Equals(loadVersion)) return ver.data;
                }
            }
            return "";
        }

        #endregion

        /// <summary> get all of the Height Code</summary>
        /// <returns>string[]: Height Code string </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string[] GetHtCodes()
        {
            ArrayList aList = new ArrayList();
            //get all of the Height Code from each position
            foreach (CargoPositionHold hold in this.theAirType.CargoPosition.hold)
            {
                foreach (CargoPositionHoldCmp cmp in hold.cmp)
                {
                    foreach (CargoPositionHoldCmpBay bay in cmp.bay)
                    {
                        foreach (CargoPositionHoldCmpBayPos posn in bay.pos)
                        {
                            if (posn.highCode != null)
                            {
                                aList.AddRange(Strings.StringToList(posn.highCode));
                            }
                        }
                    }
                }
            } 

            aList.Sort();

            return (string[])Strings.StringToList(Strings.ListToString(aList)).ToArray(typeof(string));
        } 

        /// <summary>Sort the No fit patterns by Name length</summary>
        /// <returns>sorted No fit patterns</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public AirtypeCargoVersionLoadVersionNofitPattern[] SortNofitPatterns(AirtypeCargoVersionLoadVersionNofitPattern[] patternList)
        {
            for (int len = patternList.Length - 1; len >= 0; len--)
            {
                int l = patternList[len].names.Length;
                for (int i = 0; i < len; i++)
                    if (patternList[i].names.Length > l) //by Name length
                    {
                        AirtypeCargoVersionLoadVersionNofitPattern tmp = patternList[i];
                        patternList[i] = patternList[len];
                        patternList[len] = tmp;
                    }
            }
            return patternList;
        }

        /// <summary>Has Increased Cumulative Load Limit or not</summary>
        /// <returns>has or has not</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public bool IncreasedCumulativeLoad()
        {
            if (theAirType.CargoFormula != null)
            {
                foreach (CargoFormulaInfo formula in theAirType.CargoFormula.info)
                    if (formula.icuWt != formula.ncuWt) return true;
            }
            return false;
        }

        //#BR071004 <--

        /// <summary>
        /// Use container information to get latch data
        /// </summary>
        /// <param name="cmpNo"></param>
        /// <param name="mixPattern"></param>
        /// <returns>latch position data</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string GetLatchInfo(int cmpNo, string mixPattern)
        {
            mixPattern = mixPattern.ToUpper(); // Loaded cargo type in some compartment
            int iLen = mixPattern.Length; // Length of loaded cargo in some compartment
            int idxK = mixPattern.IndexOf('K'); // index of "K" type cargo in some conpartment
            int idxA = mixPattern.LastIndexOf('A'); // index of 'A' type cargo in some conpartment
            int idxM = mixPattern.LastIndexOf('M'); // index of 'M' type cargo in some conpartment
            int idxB = mixPattern.IndexOf('B'); // Blank space in some conpartment

            if ((idxB > -1) && ((idxB < idxA) || (idxB < idxK) || (idxB < idxM))) throw (new Exception("Incorrect loading type"));
            switch (idxK)
            {
                case -1: // X/3, like AAA, AMM, ......
                    if ((iLen > 3) || (iLen == 0)) throw (new Exception("Incorrect loading type"));
                    return GetLatchPosition(cmpNo, mixPattern, 0);
                case 0: // X/0, like KKKKK, KKKK, KKK, KK, K																																																																																																																																												
                    if (iLen > 5) throw (new Exception("Incorrect loading type"));
                    return GetLatchPosition(cmpNo, "", iLen);
                case 1: // X/1, like M, A, MK, ......
                    if ((idxA > idxK) || (idxM > idxK)) throw (new Exception("Incorrect loading type"));
                    if (iLen > 4) throw (new Exception("Incorrect loading type"));
                    return GetLatchPosition(cmpNo, mixPattern.Substring(0, 1), iLen - 1);
                case 2: // X/2, like MM, MA, AAK, ......
                    if ((idxA > idxK) || (idxM > idxK)) throw (new Exception("Incorrect loading type"));
                    if ((iLen == 4) && !mixPattern.Substring(0, 2).Equals("AA")) throw (new Exception("Incorrect loading type"));
                    if (iLen > 3)
                    {
                        if (iLen == 4)
                        {
                            if (!mixPattern.Substring(0, 2).Equals("AA")) throw (new Exception("Incorrect loading type"));
                        }
                        else throw (new Exception("Incorrect loading type"));
                    }
                    return GetLatchPosition(cmpNo, mixPattern.Substring(0, 2), iLen - 2);
                default:
                    throw (new Exception("Incorrect loading type"));
            }
        }

        /// <summary>
        /// Use compartment information to get latch data
        /// </summary>
        /// <param name="cmpNo"></param>
        /// <param name="pPattern"></param>
        /// <param name="kPair"></param>
        /// <returns>latch position data</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string GetLatchPosition(int cmpNo, string pPattern, int kPair)
        {
            // string posChr="A"; // obsolesence
            string posChr = "";
            string latchPos = "";
            int pLen = pPattern.Length; // length of loaded cargo in some aompartment
            try
            {
                int cptLen = theAirType.CargoInfomation.LatchPosition[0].Compt.Length;// Amount of Compartment's data
                // if (cmpNo==1 || cmpNo==3) posChr="F"; // obsolesence
                pPattern = pPattern.ToUpper();
                if (cptLen == 0) return latchPos; // No latch data in this airtype
                cptLen = 0;
                foreach (CargoInfomationLatchPositionCompt Clp in theAirType.CargoInfomation.LatchPosition[0].Compt)
                {
                    if (Convert.ToInt32(Clp.No, 10) == cmpNo) // locate to some compartment
                    {
                        if (pLen == 0)
                        {
                            if (Clp.LDV_type.Length == 0) return latchPos;
                            foreach (CargoInfomationLatchPositionComptLDV_type LDVtype in Clp.LDV_type)
                            {
                                if (LDVtype.P_info.Trim().Length == 0)
                                {
                                    //string aaa = this.theAirType.CargoPosition.hold.ToString();							
                                    latchPos = GetCodeKPosition(kPair, posChr, LDVtype);
                                    break;
                                }
                            }
                        }
                        else
                        {
                            foreach (CargoInfomationLatchPositionComptLDV_type LDVtype in Clp.LDV_type)
                            {
                                if (LDVtype.P_info.Length == 0) continue;
                                if (pPattern.Substring(0, LDVtype.P_info.Length).Equals(LDVtype.P_info.Trim()))
                                {
                                    if (latchPos.Length > 0) latchPos += ",";
                                    latchPos += posChr + LDVtype.latch_pos;
                                    if (LDVtype.P_info.Trim().Length == pLen)
                                    {
                                        if (kPair > 0) latchPos += "," + GetCodeKPosition(kPair, posChr, LDVtype);
                                        break;
                                    }
                                }
                            }
                        }
                        return latchPos;
                    }
                    else continue;
                }
            }
            catch
            {
                return "";
            }
            return latchPos;
        }

        /// <summary>
        /// Use basecode K's information to get latch data
        /// </summary>
        /// <param name="kPair"></param>
        /// <param name="posChr"></param>
        /// <param name="LDVtype"></param>
        /// <returns>latch position data</returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string GetCodeKPosition(int kPair, string posChr, CargoInfomationLatchPositionComptLDV_type LDVtype)
        {
            string latchPos = "";
            foreach (CargoInfomationLatchPositionComptLDV_typeAttachLD3 attachLD3 in LDVtype.attachLD3)
            {
                if (kPair.ToString().Equals(attachLD3.amount.Trim()))
                {
                    latchPos = posChr + attachLD3.latch_pos;
                    break;
                }
                else continue;
            }
            return latchPos;
        }

        //#BR071004 -->

        #region SHC-CATG-NOTOC-DG Data Collection
        ///#BR071007 <--
        /// <summary>
        ///  get the restriction of some SHC  
        /// </summary>
        /// <param name="shc">SHC name </param>
        /// <returns>String：SHC restriction </returns>
        /// <remarks>
        /// Modified Date:
        /// Modified By:
        /// Modified Reason:
        /// </remarks>
        public string getShcRestriction(string shc)
        {
            try
            {
                if (shc != null)
                {
                    foreach (AirtypeShcInfo shcInfo in theAirType.SpecialLoadRestriction)
                        if (shcInfo.shc == shc) return shcInfo.restriction.ToString();
                    //	Can not fine this SHC
                    //  MessageBox.Show(this, "Can not fine this SHC -- "+shc, "SHC Exception", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                return null;
            }
            catch
            {
                return null;
            }
        }

        //#BR071007 -->
        #endregion
    }
}